# 云平台架构及选型

## 基于云计算的3种服务模式

![image-20210125205546679](/home/james/.config/Typora/typora-user-images/image-20210125205546679.png)

### Iaas:基础设施即服务（Infrastructure-as-a-Service）

IaaS的优势在于消费者不管理或控制任何云计算基础设施，但能控制操作系统的选择、存储空间、部署的应用，也有可能获得有限制的网络组件（例如路由器，防火墙，负载均衡器等）的控制。在运作成本上，节约硬件何维护两方面的成本。
目前比较知名的IaaS公司有亚马逊、Bluelock、CSC、GoGrid、IBM等。

### PaaS平台即服务（Platform-as-a-Service）

PaaS能为企业提供定制化研发的中间件平台，同时涵盖数据库和应用服务器等。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。
PaaS公司与IaaS公司有许多重叠，除了上面列出的那些之外，还有Google、Microsoft Azure、Force.com、,Heroku、Engine Yard等。

### SaaS软件即服务（Software-as-a-Service）

也是我们目前普通用户接触最多的层面，在网络上任意一个远程服务器上的应用都是属于SaaS。比如现在阿里的钉钉、JIBUU以及苹果的iCloud都属于这一类。

比较知名的SaaS公司有Salesforce、workday、Slack等。

## 虚拟化技术和容器技术

### 虚拟化技术

在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。虚拟化分类：

#### 硬件虚拟化

硬件虚拟化技术就是指计算机硬件本身提供能力让客户机指令独立执行，而不需要 （严格来说是不完全需要）VMM截获重定向。 以x86架构为例，它提供一个略微受限制的硬件运行环境供客户机运行（non-root mode [2]），在绝大多数情况下，客户机在此受限环境中运行与原生系统在非虚拟化环境 中运行没有什么两样，不需要像软件虚拟化那样每条指令都先翻译再执行，而VMM运行 在root mode，拥有完整的硬件访问控制权限。仅仅在少数必要的时候，某些客户机指令 的运行才需要被VMM截获并做相应处理，之后客户机返回并继续在non-root mode中运 行。可以想见，硬件虚拟化技术的性能接近于原生系统[3]，并且，极大地简化了VMM的 软件设计架构。

* 英特尔虚拟化技术（IVT，Intel Virtualization Technology）是由英特尔开发的一种虚拟化技术，利用IVT可以对在系统上的客操作系统，通过虚拟机查看器（VMM，Virtual Machine Monitor）来虚拟一套硬件设备，以供客操作系统使用。这些技术以往在VMware与Virtual PC上都通过软件实现，而通过IVT的硬件支持可以加速此类软件的进行。
* AMD虚拟化（AMD Virtualization），缩写为“AMD-V”，是AMD为64位的x86架构提供的虚拟化扩展的名称，但有时仍然会用“Pacifica”（AMD开发这项扩展时的内部项目代码）来指代它。

#### 软件虚拟化技术

软件虚拟化，顾名思义，就是通过软件模拟来实现VMM层，通过纯软件的环境来模 拟执行客户机里的指令。 最纯粹的软件虚拟化实现当属QEMU。在没有启用硬件虚拟化辅助的时候，它通过软 件的二进制翻译[1]仿真出目标平台呈现给客户机，客户机的每一条目标平台指令都会被 QEMU截取，并翻译成宿主机平台的指令，然后交给实际的物理平台执行。由于每一条都 需要这么操作一下，其虚拟化性能是比较差的，同时其软件复杂度也大大增加。但好处是 可以呈现各种平台给客户机，只要其二进制翻译支持。

### 容器技术

Linux Container（简称LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container主要由Namespace和Cgroup两大机制来保证实现。当前docker几乎成了容器技术的代名词，容器技术可以看作是专为解决虚拟机技术的缺点而生。容器技术就是使用宿主机的内核系统加上自身的文件系统。运行容器时是在使用宿主机的内核情况下加载文件系统，精简的文件系统可以小到100MB以内，所以比虚拟机自然要快很多。可以将容器看作是在内核上运行的独立代码单元，它们非常轻。因此占用的资源也少。

![Deployment evolution](https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg)

## 搭建云平台涉及的技术框架

### Openstack+KVM

**KVM**（Kernel-based Virtual Machine）是一个开源的系统虚拟化模块，它需要硬件支持，如Intel VT技术或者AMD V技术，是基于硬件的完全虚拟化，完全内置于Linux。每一个虚拟机都拥有自己的内核和文件系统，完全是一个独立的操作系统。而上图是两种虚拟化方式中的其中一种：半虚拟化——KVM。在目前的环境中，KVM虚拟化技术是使用率最高的技术。

![image-20210125210234380](/home/james/.config/Typora/typora-user-images/image-20210125210234380.png)

虚拟化优点:隔离性强，所有的虚拟机都有自己的协议栈，各个虚拟机底层相互隔离。
虚拟化缺点：资源占用多，虚拟化技术本身占用资源，宿主机性能有10%左右的消耗。

Openstack使用python语言开发。其最初只是为了美国宇航局（Nebula运算平台）等官方和版官方机构提供IaaS基础设施即服务的软件，而其开源的特点让任何人都可以自行创建和提供云计算服务，这对于企业创建防火墙内私有云提供了有力的支持。所以说OpenStack 主要针对 **Iaas 平台**，以资源为中心，可以为上层的 PaaS 平台提供存储、网络、计算等资源。虚拟物理机这个动作，需要一个中间层例如KVM、Xen、Hyper-V等，来基于硬件做资源的虚拟化，然后此时openstack通过各种API接口来接管这些资源。OpenStack是基于KVM开发的，KVM常常成为默认的虚拟机管理程序。

#### **Openstack使用场景**

**场景一**：安全和隔离。OpenStack适用于搭建私有云以及基于私有云的使用的场景。OpenStack底层使用了虚拟化技术，其基因中就有着隔离性好，稳定，部署灵活等特点。在OpenStack的成功案例中，云桌面是典型的例子。有不少的企业都已经将自己的生产环境搬到云端，例如企业上云，工作环境就是使用云桌面的形式。第一是降低了设备成本，上云之前是每人一台主机，到现在几十个人使用一台服务器，如果考虑cpu，内存使用率，成本肯定降下来了。第二是安全，所有的数据都不是存储在身边，在一些安全系数高的行业中尤为重要。OpenStack一直受到金融行业的青睐，这里少不了看中OpenStack安全的特性。

**场景二**：提供基础设施。OpenStack是定位于laas平台的项目，其优点是能够提供虚拟机这种很底层的设施。如果在业务场景中很依赖虚拟机，例如编译内核，或者驱动开发等这些场景，那么OpenStack是很好的选择。

**场景三**：存储需求。存储是OpenStack另一个优势所在。OpenStack第一个版本的项目组成就是存储和计算，在后期不断的开发中，存储作为一个重要的功能一直不断的完善和创新。如cinder块存储，ceph共享存储能。在存储需求很大的场景下，OpenStack能够提供高效，安全的存储方案，这也是为什么电信行业看好OpenStack的一个原因。

**场景四**：动态数据场景。即不需要反复地创建和销毁这些服务的运行环境。虚拟机优势在于稳定，那么OpenStack优势也在于运行稳定的项目。

#### 系统架构

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/9/9/165bf0bd42a6b272?imageView2/0/w/1280/h/960/ignore-error/1)

openstack项目几乎都是基于服务化设计，项目都实现了REST http协议的api和暴露api，各个项目都是用的各自的数据库， 服务之间解耦用了消息队列，性能服务会用到内存数据库memcache, 这些设计在很大程度上提升整个系统的可用性和稳定行，你可以直接将应用分布式系统中的一些解决思路放在openstack项目中，像负载均衡，服务发现，熔断等等。不过所有项目加起来一起维护就会相对较复杂，需要做好系统架构，然后配合一套相对自动化的运维体系，最后还做好自身的监控告警等。

### Kubernetes（K8s）+docker

*Docker* 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口，Docker基于LXC(Linux Container)技术，Linux Container容器是一种Linux内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，免费开源。

Kubernetes是容器管理编排引擎，底层实现自然是容器技术。更像是一个云容器时代的一个杀手级应用，更偏向于PAAS，他的目的是高效的管理服务容器，是一个高效的容器编排引擎，它不仅实现了基本的容器调度，还实现了微服务调度框架，具体像集中的配置管理中心, ConfigMap, 服务发现与负载均衡 Service & Ingress, 服务调度编排, Controller, 服务动态缩,Heapster, Autoscaling， 容错和高可用, Health Check &resource isolation, Deployment。所以可以看出，kubernetes是一个能更好构建微服务的工具，在平台层解决了微服务的问题(其他Spring Cloud相关比较本文不与介绍)，能快速的将公司的架构服务化。

#### **K8S使用场景**

**场景一**：Kubernetes适用于业务变化快，业务量未知的静态使用场景。所谓静态使用场景是指在其创建的容器中不会实时产生数据的场景。例如：网站架构，一次部署，长时间使用。特别是遇到一些线上业务量不确定的场景，Kubernetes能够动态扩展，灵活伸缩，从5W的并发量到10W的并发量，完全可以秒级处理。

**场景二**：需要反复地创建和销毁这些服务的运行环境。docker的优势就在于启动快速，消耗资源小。所以在需要频繁创建和销毁的场景中，Kubernetes是一个不错的选择。

**场景三**：需要业务模块化和可伸缩性：容器可以很容易地将应用程序的功能分解为单个组件，符合微服务架构的设计模式。

**场景四**：应用云化。将已有应用、要新开发的应用打造成云原生应用，发挥云平台的可扩展、弹性、高可用等特性，并借助PaaS层提供的API实现更高级的特性，比如自动恢复、定制化的弹性伸缩等。

**场景五**：微服务架构和API管理。服务拆分来抽象不同系统的权限控制和任务，以方便业务开发人员通过服务组合快速的创建企业应用。有的企业在没有对应的管理平台之前就已经将应用拆分成很多服务，如何部署这些微服务和进行API权限控制，则成了需要解决的问题，而Kubernetes代表的PaaS则是理想的选择。

#### 系统架构

![Components of Kubernetes](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

kubernetes自身的服务就比较简化， 服务之间设计主要通过grpc, http协议进行通信，也是进行服务化设计，会用到etcd去注册发现， 中心化服务相对好扩展。唯一相对严峻问题是大量主机(>5000)或大量Pods(>10万)级别下的etcd横向扩展的性能问题。当然单单从kubernetes的设计去考虑，也有其他的方式去解决问题。

## 资源场景对比

### 网络

#### openstack

openstack实现了基于软件的虚拟化SDN网络

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/9/9/165bf0bd414bd802?imageView2/0/w/1280/h/960/ignore-error/1)

openstack虚拟网络(Neturon)是它非常核心的一个模块，完全用软件的方式实现了网络控制器，利用linux birdge, openvswitch等技术实现网络隔离与网络虚拟化，同时有高度的自定义功能，可以有多种vlan, vxlan, gre协议去可配置的实现overlayer网络，让用户自定义的去操作虚拟路由器，交换机等等, 在架构上它会有专门的网络节点做三层网络节点。

#### kubernetes

kubernetes : 利用各大CNI开源组件组建网络

![这里写图片描述](https://user-gold-cdn.xitu.io/2018/9/9/165bf0bdc074775c?imageView2/0/w/1280/h/960/ignore-error/1)

有很多开源的网络插件像flannel, calico, weave等等很多，每个组件都有自己的优势，有通过vxlan, 有直接是基于二层路由协议的， 应用场景和性能也会有所不同。相对来说kubernetes没有指定某种实现，而主要去实现一种网络接口，让各大厂商或云可以利用各自的优势去实现不同的overlay，所以他也不会有专门的网络节点。

### 存储

#### openstack 

openstack提供对象存储，块存储

openstack 根据自己的需求实现了块存储和对象存储，自身的对象存储会用在像glance这样的镜像服务，块存储会用在vm之间的共享和自定义挂载，它的存储都是独立的项目，独立的去解决各自的问题，而且从最开始的设计思路就像标准化的存储去实现，可扩展强，支持分布式，对接相对容易，当然openstack 也能对接其他的存储，比如像ceph。

####  kubernetes

kubernetes 不实现存储, 而是实现存储驱动和接口(CSI)。

kuberntes 只是一个使用者的角度, kuberntes不是去实现一种针对容器较好的存储方案，而是去对接各个存储引擎。像比较主流的Nfs, Glusterfs, ceph, 以及像各个公有云的云存储组件。

### 资源隔离

#### openstack

openstack 隔离性相对较高

完善的多资源的多租户隔离，对vm是针对内核层面的隔离，网络从协议层面作隔离，也有一些流量控制工具Linux Traffic Control, 存储也有各自的配额管理。

#### kubernetes

docker(containerd+runc)隔离性相对较低

隔离程度相对较低，不支持多租户，对资源池的管理基于resource, 和 namespace，隔离性相对较弱，对具体pods容器的管理基于cgroup,和namespace，不是基于内核层面。所有容器公用内核，隔离性相对较差。

针对基于namespace隔离方案的弱隔离性，社区发展了katacontainer、gvisor、firecracker等基于kvm全虚拟化的CRI项目。能有效的减少攻击面，降低逃逸的可能，提供了与传统kvm虚拟机一样的强隔离能力。并通过裁减内核，优化系统调用等措施，提供了稍弱于runc的启动速度。